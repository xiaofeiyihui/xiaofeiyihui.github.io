<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="​        本篇是数据结构与算法系列博客的开山之篇，想写这个系列博客很久了，一直没想好该用什么方式来展开讲，最近也看了一些相关类的书，如：《算法图解》，《我的第一本算法书》，《大话数据结构》(还未看完)，感触挺多的，老师们都有一套自己的理解，讲的通俗易懂。但是怎么才能灵活应用这些数据结构，单独看某一类数据结构都懂，一到实际应用或者自己写一个综合的数据结构的时候就蒙圈。怎么才能摆脱这种尴尬，思">
<meta name="keywords" content="数据结构与算法,源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法之开山篇：hashmap数据结构及源码分析">
<meta property="og:url" content="https:&#x2F;&#x2F;xiaofeiyihui.github.io&#x2F;2019&#x2F;12&#x2F;10&#x2F;2019-12-10-hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="小飞一会">
<meta property="og:description" content="​        本篇是数据结构与算法系列博客的开山之篇，想写这个系列博客很久了，一直没想好该用什么方式来展开讲，最近也看了一些相关类的书，如：《算法图解》，《我的第一本算法书》，《大话数据结构》(还未看完)，感触挺多的，老师们都有一套自己的理解，讲的通俗易懂。但是怎么才能灵活应用这些数据结构，单独看某一类数据结构都懂，一到实际应用或者自己写一个综合的数据结构的时候就蒙圈。怎么才能摆脱这种尴尬，思">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;4.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;5.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;7_cr.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;8_left.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;9_right.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;12.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;10_left.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;13.png">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;11_right.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;6.png">
<meta property="og:updated_time" content="2019-12-19T15:25:46.817Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;xiaofeiyihui.gitee.io&#x2F;cdn&#x2F;images&#x2F;hashmap&#x2F;1.png">

<link rel="canonical" href="https://xiaofeiyihui.github.io/2019/12/10/2019-12-10-hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数据结构与算法之开山篇：hashmap数据结构及源码分析 | 小飞一会</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小飞一会</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一步一步往前走</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/xiaofeiyihui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaofeiyihui.github.io/2019/12/10/2019-12-10-hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myAvatar.jpg">
      <meta itemprop="name" content="Mr.Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小飞一会">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法之开山篇：hashmap数据结构及源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-10 10:17:37" itemprop="dateCreated datePublished" datetime="2019-12-10T10:17:37+08:00">2019-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-19 23:25:46" itemprop="dateModified" datetime="2019-12-19T23:25:46+08:00">2019-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​        本篇是数据结构与算法系列博客的开山之篇，想写这个系列博客很久了，一直没想好该用什么方式来展开讲，最近也看了一些相关类的书，如：《算法图解》，《我的第一本算法书》，《大话数据结构》(还未看完)，感触挺多的，老师们都有一套自己的理解，讲的通俗易懂。但是怎么才能灵活应用这些数据结构，单独看某一类数据结构都懂，一到实际应用或者自己写一个综合的数据结构的时候就蒙圈。怎么才能摆脱这种尴尬，思考了很多，唯有深入专研,探究其奥秘，方能得心应手。</p>
<p>​        这一篇将从数据结构的角度来分析hashmap,文中涉及的源码较多，所以会一起将源码一起梳理。</p>
<a id="more"></a>

<h2 id="HashMap数据结构分析"><a href="#HashMap数据结构分析" class="headerlink" title="HashMap数据结构分析"></a>HashMap数据结构分析</h2><h3 id="HashMap中使用的数据结构"><a href="#HashMap中使用的数据结构" class="headerlink" title="HashMap中使用的数据结构"></a>HashMap中使用的数据结构</h3><p>在hashmap中，抛开一些方法的类外，使用到了一下数据结构</p>
<h4 id="1-Node-class-："><a href="#1-Node-class-：" class="headerlink" title="1.Node.class  ："></a>1.Node.class  ：</h4><p>单项链表结构，存放hashmap中的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-TreeNode-class："><a href="#2-TreeNode-class：" class="headerlink" title="2.TreeNode.class："></a>2.TreeNode.class：</h4><p>红黑树结构，存放hashmap中的数据，其实时Node的一个子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       TreeNode&lt;K,V&gt; left;</span><br><span class="line">       TreeNode&lt;K,V&gt; right;</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">       <span class="keyword">boolean</span> red;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// LinkedHashMap.Entry&lt;K,V&gt; 结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; before, after;</span><br><span class="line">       Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-hashmap自带的字段类的"><a href="#3-hashmap自带的字段类的" class="headerlink" title="3.hashmap自带的字段类的"></a>3.hashmap自带的字段类的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- 字段中的默认值 -------------- */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">    * hashmap默认的初始化大小： 2的4次方，即16，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">    * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">    * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">    * hashmap最大容量：2的4次方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">    * hashmap默认的负载因子，默认0.75，即达到总容量的75%时，需要扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">    * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">    * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">    * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">    * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">    * shrinkage.</span></span><br><span class="line"><span class="comment">    * 转化树形结构的阈值，默认8，即当某个链表上的节点长度大于8时，将这</span></span><br><span class="line"><span class="comment">    * 个链表转化为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">    * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">    * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">    * 从树形结构转化为单链表结构的阈值，默认6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">    * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">    * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">    * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">    * 对字段TREEIFY_THRESHOLD的一个补充，转化为红黑树的最小hashmap容量，</span></span><br><span class="line"><span class="comment">    * 如果某个链表的节点长度&gt;8,但是总容量没达到64，hashmap会扩容，而不是</span></span><br><span class="line"><span class="comment">    * 直接转化为红黑树。（自定义该值时，至少应为4 * TREEIFY_THRESHOLD以</span></span><br><span class="line"><span class="comment">    * 避免在扩容还是转化为红黑树时产生冲突）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">  <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">    * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">    * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">    * 存储链表元素的数组，初始化或者扩容的时候会用，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">    * for keySet() and values().</span></span><br><span class="line"><span class="comment">    * 具体的几点数据集合，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">    * hashmap总节点的个数，即容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">    * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">    * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">    * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">    * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">    * 记录hashmap被修改的次数，包括rehash,添加数据等，在遍历数据时可以起到快速</span></span><br><span class="line"><span class="comment">    * 失败的作用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">    * 下一次扩容的阈值，capacity * load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">   <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">   <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">   <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">    * 负载因子</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="4-继承-AbstractMap-lt-K-V-gt-的字段"><a href="#4-继承-AbstractMap-lt-K-V-gt-的字段" class="headerlink" title="4.继承 AbstractMap&lt;K,V&gt;的字段"></a>4.继承 AbstractMap&lt;K,V&gt;的字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key的集合缓冲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;  keySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value的集合缓冲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能有人会问，为什么要在字段前加 transient， 这个其实只是想在对象序列化的时候不包含这个字段。</p>
</blockquote>
<p>从上面的分析可以知道hashmap中使用了数组，单链表，二叉树的结构。其他字段都是为了统计或者处理不同结构转换的阈值。如图：</p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/1.png" alt="1"></p>
<h3 id="HashMap怎么运用这些数据结构"><a href="#HashMap怎么运用这些数据结构" class="headerlink" title="HashMap怎么运用这些数据结构"></a>HashMap怎么运用这些数据结构</h3><p>HashMap是怎么应用这些结构呢，让我们从源码的角度来分析。</p>
<h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造，只设置默认负载因子 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造，自定义初始化容量，使用默认的负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造：设置初始化容量，负载因子，计算下一次扩容的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//计算下一次扩容的阈值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用默认的负载因子，初始化hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面构造函数上看不出来是如何使用这些数据结构的，我们再来看看添加方法</p>
<h4 id="2-添加方法"><a href="#2-添加方法" class="headerlink" title="2.添加方法"></a>2.添加方法</h4><h5 id="put-gt-putVal"><a href="#put-gt-putVal" class="headerlink" title="put()  -&gt;  putVal()"></a>put()  -&gt;  putVal()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1.table如果是空数组，走扩容resize()逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.如果找到的链表头结点为null,直接新建一个next为null的节点，用(n - 1) &amp; hash找到对应的链表头</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.走到这里，代表hashmap不为空，对应的链表也不为空，就涉及到在节点上添加数据，但是</span></span><br><span class="line"><span class="comment">     * 添加数据又不确认是链表结构还是红黑树结构，所以这里还有分化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 3.1头结点就是要找的位置(hash值相等，key也相等)，将头结点赋值给临时变量e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 3.2如果头结点不是要找的，判断节点的数据结构，是树结构，按红黑树的方式添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是链表结构，遍历链表，找到链表尾部，即next为null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没找到与新增key相等的节点,在链表尾部新增一个节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 因为新增了节点，所以需要考虑是不是满足了转化为红黑树的条件</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还没到链表尾部就找到了与key相等的节点，退出遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 没找到将p的指针后移，继续遍历</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历完后，p指向链表的倒数第二个节点，e指向添加新节点前的p.next或是</span></span><br><span class="line">            <span class="comment">// e=p(头结点时)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加数据有两种情况，一种是key已经存在(此时e!=null),另一种是key(此时e=null)不存在</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// oldValue为null或者指定要修改原值时，在找到的节点上用新的value替换oldValue</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//这个在hashmap是个空方法，主要是留给LinkedHashMap去实现的</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hashmap被修改的次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 容量加1，和阈值比较，看是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 同afterNodeAccess</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面添加方法源码我们可以知道，添加主要干了这几件事：</p>
<blockquote>
<p>1.hashmap为空，调用resize()初始化一个；</p>
<p>2.如果找到的链表的头结点null，第一次hash到这个位置，使用key，value新建一个都节点,然后修改统计字段modCount，size，如果size超过了扩容阈值，就扩容，然后返回null(在这一步是可以看出数组里面的元素是Node)；</p>
<p>3.如果头结点已经存放过值，分以下几种情况：</p>
<p>​    3.1，头结点就是要找的节点，看是否需要修改oldValue，然后返回oldValue</p>
<p>​    3.2，头结点不是要找的节点，又分节点是单链表结构(Node&lt;K,V&gt;)还是红黑树结构(TreeNode&lt;K,V&gt;)</p>
<p>​        3.2.1，单链表：遍历节点，找到匹配的节点，如果遍历完都没找到就在链表尾部新增一个几点，此时需要考虑是否满足转化为红黑树的条件，后续还需要修改modCount，size，考虑是否满足扩容条件；如果在遍历的过程中就找到了匹配的节点(即以前用这个key存储过值)，看是否需要修改oldValue，然后返回oldValue;</p>
<p>​        3.2.2，红黑树：按照红黑数的方式添加数据，源码抽取了一个方法，但是操作和单链表的方式大致相同，不同的事遍历方式，后面源码中会详细介绍。</p>
</blockquote>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/4.jpg" alt="1"></p>
<p>分析完添加方法的逻辑后有没有发现，要是我们的数据结构是这样设计的，我们自己去实现添加方法时，整个逻辑也会是这样，并没有什么高深难懂的，当然其中用到的一些算法也很值得我们去学习。</p>
<p>tips：</p>
<blockquote>
<p>1.通过hash值找对应的链表时，采用tab[i = (n - 1) &amp; hash]方式，等价于tab[i = hash % n]，但是(n - 1) &amp; hash方式更加高效。</p>
<p>2.源码中还有一个很好的函数式编码风格，采用临时变量去处理逻辑，如： K k; (k = p.key) == key。</p>
<p>3.单链表转化为红黑树是针对某一个链路的，扩容是针对table数组，即链表的数量。</p>
</blockquote>
<p>通过上面分析，我们可以看出hashmap数据结构(主要是Node&lt;K,V&gt;[] table,Node&lt;K,V&gt;,TreeNode&lt;K,V&gt;)的应用，如下图：</p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/2.png" alt="1"></p>
<p>某个单链表转化成红黑树的条件是：链表长度&gt;=8 且总容量size&gt;=64</p>
<h3 id="hashmap数据结构小结"><a href="#hashmap数据结构小结" class="headerlink" title="hashmap数据结构小结"></a>hashmap数据结构小结</h3><p>为什么要这么设计一个数据结构呢？我想这和hashmap的使用场景有关，hashmap就是维护着一个散列表，我们需要频繁在上面增删改查数据，数据一多，效率就成了问题。为了解决这个问题，单独使用某一种基本数据结构肯定不行，所以需要综合各个基本数据结构的有点来设计，比如数组的查询时间复杂度为O[1]，用它的作为桶固定大小；链表的插入、删除时间复杂度为O[1]，用它来添加删除节点；随着数据的增多，单个链表的长度会越长，在链表上查询数据的效率又成为问题，然后就会想到二叉树结构， 插入和查找 时间复杂度为 O(log(n)) 。这中间也用到我们经常听到的一种手法：<strong>空间换时间</strong>。</p>
<p>好了，hashmap数据结构的分析到这里就告一段了，下面我们接着来欣赏源码。</p>
<h2 id="hashmap源码分析"><a href="#hashmap源码分析" class="headerlink" title="hashmap源码分析"></a>hashmap源码分析</h2><h3 id="1-添加方法相关的源码"><a href="#1-添加方法相关的源码" class="headerlink" title="1.添加方法相关的源码"></a>1.添加方法相关的源码</h3><p>上面我们已经介绍过添加方法的源码，里面涉及到的resize()，treeifyBin(),putTreeVal()我们接着分析。</p>
<h4 id="resize-：扩容"><a href="#resize-：扩容" class="headerlink" title="resize()：扩容"></a>resize()：扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// 将扩容前的table，cap,threshold分别赋值给临时变量oldTab，oldCap，oldThr</span></span><br><span class="line">       <span class="comment">// 刚创建的hashmap对象，table为null,cap为0，threshold为在没有指定容量时为0，否则也不为0</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 1.如果扩容前的容量大于0，不是第一次添加值</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//1.1 判断扩容前容量是不是大于最大容量，如果是不扩容，把扩容阈值也设置为最大容量值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 1.2 对oldCap增大到2倍后，判断容量是不是小于最大容量并且&gt;=默认容量</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//新阈值设置为原来的两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2.如果扩容前的容量&lt;=0，判断扩容前的阈值是否&gt;0;如果&gt;0,那扩容后的容量设置为oldThr</span></span><br><span class="line">       <span class="comment">// 创建hashmap对象时给定初始容量，第一次添加数据会出现cap&lt;=0,oldThr&gt;0</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">// 3. 扩容前的容量和阈值都&lt;=0,使用无参构造创建对象，第一次添加值，初始化为默认值</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//上面逻辑走的是2，重新计算下次扩容的阈值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将阈值赋值给实例对象字段threshold</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="comment">//因为是扩容，所以会重新创建一个</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">// 扩容前有数据会走到这个逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//遍历老数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">//如果当前处的链表结构有数据，这里已经把链表头赋值给了临时变量e</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//1.只有一个头结点，这个时候不用关心是单链表结构还是红黑树结构</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">//重新计算key的hash在扩容后数组中新的位置</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">// 2.当前节点属于红黑树节点类型，按照红黑树的方式处理，这里先不展开</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">//3.走到这，可以确定是单链表结构了，按照单链表的方式处理</span></span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">//这里定义了两个高低位链表头结点和尾节点</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="comment">//循环遍历链表oldTab[j]，知道节点的next=null</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 以第一次扩容为例，如果key的hash值落在0-15之间的，放在低位链表</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// 第一次走到这里，将e给头结点，</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="comment">//不是第一次落在低位链表，将新节点添加在尾部</span></span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               <span class="comment">// loTail指向最新的尾部</span></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//hash值落在16-31之间的，放在高位链表</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">//逻辑同低位链表</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//低位链表放在扩容后j的位置，并把尾部节点的next指向置为null</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                      <span class="comment">//高位链表放在j+pldCap的位置，hiTail.next置为null</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>1.有很多同学会对hash &amp; n  与hash &amp; (n-1)产生疑惑？</p>
<blockquote>
<p>这个地方设计的相当 巧妙，我们以n=16为例来讲解：</p>
<p>16 - 1 = 15, 二进制表示为 <code>0000 0000 0000 0000 0000 0000 0000 1111</code><br>可见除了低4位, 其他位置都是0,简写为<code>1111</code>， 则 <code>(16-1) &amp; hash</code> 自然就是取hash值的低4位（假设<code>abcd</code>）,所以我们用<code>hash &amp; (n-1)</code>来确定hash在table数组中的位置.</p>
<p>以此类推, 当我们将oldCap扩大两倍后, 新的index的位置就变成了 <code>(32-1) &amp; hash</code>, 其实就是取 hash值的低5位. 那么对于同一个Node, 低5位的值无外乎下面两种情况:<code>0abcd</code>或 <code>1abcd</code>；16的二进制简写表示为<code>10000</code>,如果以16为界来区分高低位的话，我们刚好可以用它来确认hash是处在高位还是低位</p>
</blockquote>
<p>2.上面的do{}while以及后面的两个if判断做的是什么逻辑？</p>
<blockquote>
<p> 如果 <code>(e.hash &amp; oldCap) == 0</code> 则该节点在新表的下标位置与旧表一致都为 <code>j</code><br>如果 <code>(e.hash &amp; oldCap) == 1</code> 则该节点在新表的下标位置 <code>j + oldCap</code> </p>
<p>大概是这个意思：扩容前的数组范围是0-15，这个时候hash值为1,17的都会落在table[1]，当数组范围扩大到0-31时，这个时候就需要把原来的17落在table[17]才算合理</p>
</blockquote>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/5.jpg" alt="1"></p>
<h4 id="putTreeVal-：树添加节点"><a href="#putTreeVal-：树添加节点" class="headerlink" title="putTreeVal() ：树添加节点"></a>putTreeVal() ：树添加节点</h4><p>这个其实是TreeNode内部的一个方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tree version of putVal.</span></span><br><span class="line"><span class="comment">     * 指定key所匹配到的节点对象，putVal针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class="line">        <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 自旋遍历</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="comment">// 声明方向dir</span></span><br><span class="line">            <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">            <span class="comment">//1.hash决定左右方向，如果当前节点的hash大于k的h，添加的key应该在当前节点的左边，如果小于h，在右边</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前节点的键对象 和 指定key对象相同,返回当前节点，在外层方法会对v进行写入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 走到这里说明hash相等，但是key不等</span></span><br><span class="line">           <span class="comment">// 2.由key决定左右</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//第一次循环时，key没有实现comparable接口||实现了但是两个key的类型不同||类型相同，key也相同 会走到这里</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class="line"><span class="comment">                 * 如果还没有，那么就递归遍历对比，看是否能够得到key相等的的节点</span></span><br><span class="line"><span class="comment">                 * 如果得到了key相等的的节点就返回</span></span><br><span class="line"><span class="comment">                 * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    <span class="comment">//标记遍历过</span></span><br><span class="line">                    searched = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//先在左子树上找key相等的节点，找不到再到右子树上找，有找到就返回找到的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历了所有子节点也没有找到与k相等的节点，再比较一下当前节点键和指定key键的大小,来决定是在左还是在右添加节点</span></span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">            TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 如果dir小于等于0，那么看当前节点的左节点是否为空，如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">            * 如果dir大于等于0，那么看当前节点的右节点是否为空，如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                <span class="comment">// 创建一个新的树节点，</span></span><br><span class="line">                TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                <span class="comment">// 向左，将新建的节点添加到当前节点的左节点，否则添加到右节点</span></span><br><span class="line">                <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                    xp.left = x;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    xp.right = x;</span><br><span class="line">                <span class="comment">//当前节点的next指向新增的节点</span></span><br><span class="line">                xp.next = x;</span><br><span class="line">                <span class="comment">//新增节点的父节点、前节点指向当前节点</span></span><br><span class="line">                x.parent = x.prev = xp;</span><br><span class="line">                <span class="comment">// 如果原来的next节点不为空，那么原来的next节点的前节点指向到新的树节点，因为新节点是用xpn作为next创建的</span></span><br><span class="line">                <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                <span class="comment">// 重新平衡，以及新的根节点置顶</span></span><br><span class="line">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                <span class="comment">// 返回空，意味着产生了一个新节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面步骤可以为概括如下：树添加节点</p>
<blockquote>
<p>1.找到root节点，自旋遍历；</p>
<p>2.确定新节点的位置，如果添加之前已经存在直接返回，没有就创建一个新节点</p>
<p>   2.1 .用hash来找节点，找不到hash相等的，比较当前节点与指定hash的大小来决定在左还是在右添加新节点；</p>
<p>   2.2 .找到hash相等，再与key作比较，找到与key相等的节点，找到直接返回；</p>
<p> 2.3 .找不到就比较当前节点与指定key的大小来决定在左还是在右添加新节点；</p>
<p>3.平衡的添加节点，并将root节点设置为头结点</p>
</blockquote>
<h4 id="treeifyBin-：转化为树"><a href="#treeifyBin-：转化为树" class="headerlink" title="treeifyBin()：转化为树"></a>treeifyBin()：转化为树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">   * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果元素数组为空 或者 数组长度小于 树结构化的最小限制,走扩容逻辑</span></span><br><span class="line"><span class="comment">       * MIN_TREEIFY_CAPACITY 默认值64，对于这个值可以理解为：如果元素数组长度小于这个值，没有必要去进行结构转换</span></span><br><span class="line"><span class="comment">       * 当一个数组位置上集中了多个键值对，那是因为这些key的hash值和数组长度取模之后结果相同。（并不是因为这些key的hash值相同）</span></span><br><span class="line"><span class="comment">       * 因为hash值相同的概率不高，所以可以通过扩容的方式，来使得最终这些key的hash值在和新的数组长度取模之后，拆分到多个数组位置上。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">  	<span class="comment">// 大于MIN_TREEIFY_CAPACITY，根据hash值计算得到需要转换数据结构的链表</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//定义树节点的头、尾</span></span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//遍历链表，将所有节点转换为树结构</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//将当前节点转化为红黑数节点，replacementTreeNode内部其实只是new TreeNode()</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="comment">//转化链表的头结点时，tl为null,此时将树的头结点指向p</span></span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="comment">// 尾节点不为空，以下两行是一个双向链表结构</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//树尾节点指向新创建的节点</span></span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">//注意上面的步骤只是把每个节点转化为TreeNode类型的节点，并用双向链表的方式链接，节点的左右子节点以及root节点并没有处理</span></span><br><span class="line">          <span class="comment">// 树的头结点不为null,将前面转换的所有树节点连起来，</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<blockquote>
<p>1.判断table容量是否小于MIN_TREEIFY_CAPACITY，确定是走扩容逻辑还是转化为树；</p>
<p>2.找到需要转化为树的链表位置，循环遍历，将每个节点转化为树节点，在连起来</p>
</blockquote>
<h4 id="treeify-：连接树形节点"><a href="#treeify-：连接树形节点" class="headerlink" title="treeify()：连接树形节点"></a>treeify()：连接树形节点</h4><p> treeify方法是TreeNode类的一个实例方法，通过TreeNode对象调用，实现该对象打头的链表转换为树结构。 </p>
<p>在treeifyBin()方法中是<strong>头结点</strong>在调用该方法： hd.treeify(tab)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//定义root节点</span></span><br><span class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//在treeifyBin()中this指向双向链表头结点，此处是在遍历链表</span></span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">             next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">             x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//1.如果根节点为null,将当前节点设置当前节点为根节点，同时把根节点的父节点设置为null,标记为黑色</span></span><br><span class="line">             <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 x.parent = <span class="keyword">null</span>;</span><br><span class="line">                 x.red = <span class="keyword">false</span>;</span><br><span class="line">                 root = x;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//2.如果根节点不为null</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//获取当前链表节点的 key 、hash、key的class类型</span></span><br><span class="line">                 K k = x.key;</span><br><span class="line">                 <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="comment">// 自旋遍历红黑树，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">                 <span class="comment">//因为要确认链表中当前节点再红黑树中的位置，所以需要遍历插入</span></span><br><span class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                     <span class="comment">//dir 标识方向（左右）、ph标识当前树节点的hash值,pk前树节点的key</span></span><br><span class="line">                     <span class="keyword">int</span> dir, ph;</span><br><span class="line">                     K pk = p.key;</span><br><span class="line">                     <span class="comment">//如果当前树节点hash值 大于 当前链表节点的hash值,标识当前链表节点会放到当前树节点的左侧,否则标识右侧，如果hash相等,再用key的作比较</span></span><br><span class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                         dir = -<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                         dir = <span class="number">1</span>;</span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较。</span></span><br><span class="line"><span class="comment">                      * 如果当前链表节点的key实现了comparable接口，并且当前树节点和链表</span></span><br><span class="line"><span class="comment">                      * 节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                      * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                         dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                     TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      * 如果dir 小于等于0 ：当前链表节点一定放置在当前树节点的左侧，但</span></span><br><span class="line"><span class="comment">                      * 不一定是该树节点的左孩子，也可能是左孩子的右孩子或者更深层次的节点。</span></span><br><span class="line"><span class="comment">                      * 如果dir 大于0 ：当前链表节点一定放置在当前树节点的右侧，但不一</span></span><br><span class="line"><span class="comment">                      * 定是该树节点的右孩子，也可能是右孩子的左孩子或者更深层次的节点。</span></span><br><span class="line"><span class="comment">                      * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩</span></span><br><span class="line"><span class="comment">                      * 子为起始节点  再从树节点遍历处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                      * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂</span></span><br><span class="line"><span class="comment">                      * 载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                      * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点</span></span><br><span class="line"><span class="comment">                      * 进行处理了。</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                         <span class="comment">//进入这里说明当前树节点的左节点或者有节点就是当前链表要放置的位置</span></span><br><span class="line">                         x.parent = xp;</span><br><span class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                             xp.left = x;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                             xp.right = x;</span><br><span class="line">                         <span class="comment">//重新平衡</span></span><br><span class="line">                         root = balanceInsertion(root, x);</span><br><span class="line">                         <span class="comment">//中断树的遍历</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//将root设为头结点</span></span><br><span class="line">         moveRootToFront(tab, root);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p> 上面的源码小结一下：</p>
<blockquote>
<p>1.遍历链表，确定每个链表节点在树中的位;</p>
<p>2.循环遍历当前树，然后找到该链表节点可以插入的位置，依次和遍历的树节点比较，比它大则跟其右孩子比较，小则与其左孩子比较，依次遍历，直到找到左孩子或者右孩子为null的位置进行插入 </p>
</blockquote>
<h4 id="moveRootToFront-：将root设为头结点"><a href="#moveRootToFront-：将root设为头结点" class="headerlink" title="moveRootToFront()：将root设为头结点"></a>moveRootToFront()：将root设为头结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">      * 把红黑树的根节点设为  其所在的数组槽 的第一个元素</span></span><br><span class="line"><span class="comment">* 首先明确：TreeNode既是一个红黑树结构，也是一个双链表结构</span></span><br><span class="line"><span class="comment">* 这个方法里做的事情，就是保证树的根节点一定也要成为链表的首节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n;</span><br><span class="line">         <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//计算桶的位置，first指向链表第一个节点</span></span><br><span class="line">             <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">             TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">             <span class="comment">//如果root不是第一个节点，则将root放到第一个首节点位置</span></span><br><span class="line">             <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                 <span class="comment">//定义一个节点，后续存放root.next</span></span><br><span class="line">                 Node&lt;K,V&gt; rn;</span><br><span class="line">                 <span class="comment">//将根节点设置为链表的头结点</span></span><br><span class="line">                 tab[index] = root;</span><br><span class="line">                 <span class="comment">//root前驱节点</span></span><br><span class="line">                 TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                 <span class="comment">//如果root节点的next不为null,那么next的前驱设置为原root的前驱节点</span></span><br><span class="line">                 <span class="comment">//相当于把root从链表中摘除</span></span><br><span class="line">                 <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                 <span class="comment">// 如果root的前驱不为null,那么将前驱的next设置为root的后驱</span></span><br><span class="line">                 <span class="comment">//这一步root彻底从双向链表中摘除</span></span><br><span class="line">                 <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                     rp.next = rn;</span><br><span class="line">                 <span class="comment">//如果原链表第一个节点不为null,将first的前驱设置为root</span></span><br><span class="line">                 <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                     first.prev = root;</span><br><span class="line">                 <span class="comment">//root后驱指向first</span></span><br><span class="line">                 root.next = first;</span><br><span class="line">                 <span class="comment">//root没有前驱</span></span><br><span class="line">                 root.prev = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//这里是防御性编程，校验更改后的结构是否满足红黑树和双链表的特性</span></span><br><span class="line">             <span class="comment">//因为HashMap并没有做并发安全处理，可能在并发场景中意外破坏了结构</span></span><br><span class="line">             <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p> 这个方法是将root节点移动到桶中的第一个元素，也就是链表的头节点，这样做是因为在判断桶中元素类型的时候会对链表进行遍历，将根节点移动到链表前端可以确保类型判断时不会出现错误。 </p>
<blockquote>
<p> 1.将root节点从原位置抽出，原root的前后驱互相连接</p>
<p> 2.将root设置为原first节点的后驱设置为first，并将root的前驱设置为null</p>
<p> 3.重新检查树的结构</p>
</blockquote>
<h4 id="balanceInsertion-平衡插入"><a href="#balanceInsertion-平衡插入" class="headerlink" title="balanceInsertion():平衡插入"></a>balanceInsertion():平衡插入</h4><p>这个很核心的一个方法，目的是让红黑树添加新数据后继续保持平衡，putTreeVal() 、treeify()都有调用。</p>
<p>红黑树的每个节点遵循以下规则：</p>
<ul>
<li>所有节点只能是红色或者黑丝</li>
<li>根节点是黑色</li>
<li>只存在相邻的红色节点（即红色节点不能有红色的父节点或者红色的孩子）</li>
<li>任意从root到Nil节点，经过的路径中黑色节点的数目是一样的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新插入的节点标为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这一步即定义了变量，又开起了循环，循环没有控制条件，只能从内部跳出</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点、xpp：爷爷节点、xppl：左叔叔节点、xppr：右叔叔节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">// L1  如果父节点为空</span></span><br><span class="line">        <span class="comment">//说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入的节点的父节点是黑色节点，则不需要调整，因为插入的节点会初始化为</span></span><br><span class="line"><span class="comment">         * 红色节点，红色节点是不会影响树的平衡的。</span></span><br><span class="line"><span class="comment">         * 插入的节点的祖父节点为null，即插入的节点的父节点是根节点，直接插入即</span></span><br><span class="line"><span class="comment">         * 可(因为根节点肯定是黑色).</span></span><br><span class="line"><span class="comment">         * 这两种都不需要调整，直接返回原root节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//L2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//这后面的都是插入节点的父节点是红色</span></span><br><span class="line">        <span class="comment">// L3 插入的节点父节点和爷爷节点都存在，并且其父节点是爷爷节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//L3_1 插入节点的右叔叔节点存在并且是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//将右叔叔、父节点设置为黑色，爷爷节点设置为红色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//运行到这里，就又会进行下一轮的循环了,将爷爷节点当做处理的起始节点,相当于沿着子节点向根节点遍历检查是否平衡</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//L3_2 插入节点的叔叔节点是黑色或不存在</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//L3_2_1 插入节点是其父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">//父节点左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//L3_2_2 插入节点是其父节点的左孩子</span></span><br><span class="line">                <span class="comment">//此时有父节点将其设置为黑色，有爷爷节点将其设置为红色</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//爷爷节点右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// L4 插入的节点父节点和祖父节点都存在，并且其父节点是爷爷节点的右节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//L4_1 插入节点的叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//从爷爷节点开始继续向根节点遍历检查平衡</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//L4_2 如果左叔叔为空或者是黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//L4_2_1 插入节点是其父节点的左孩子</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    <span class="comment">//父节点右旋</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//L4_2_2 插入节点是其父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//爷爷节点左旋</span></span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑直接看源码不太好理解，可以参考下面的图来看源码： </p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/7_cr.png" alt="变色不旋转"></p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/8_left.png" alt="左旋"></p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/9_right.png" alt="右旋"></p>
<h4 id="rotateLeft-左旋"><a href="#rotateLeft-左旋" class="headerlink" title="rotateLeft() : 左旋"></a>rotateLeft() : 左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//r:p右节点，pp:p的父节点，rl:p的右节点的左孩子节点</span></span><br><span class="line">    		TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    		<span class="comment">//左旋的节点以及左旋的节点的右孩子不为空</span></span><br><span class="line">           <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 左旋的节点的右孩子的左节点赋给左旋的节点的右孩子 节点为：rl</span></span><br><span class="line">               <span class="comment">//1.左旋节点的右节点存在左节点，设置rl的父节点为当前节点</span></span><br><span class="line">               <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)   </span><br><span class="line">                   rl.parent = p;</span><br><span class="line">               <span class="comment">//将r的父节点指向p的父节点，相当于右孩子提升了一层</span></span><br><span class="line">       		<span class="comment">//此时如果父节点为空，说明r 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">               <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                   (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">// 如果父节点不为空并且要左旋的节点是左孩子,将r设置为父节点的左孩子，即r取代p</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                   pp.left = r;</span><br><span class="line">               <span class="comment">//如果父节点不为空并且要左旋的节点是右孩子，将r设置为父节点的右孩子，即r取代p</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   pp.right = r;</span><br><span class="line">               <span class="comment">//将p这是为r的左孩子及父节点，r彻底取代p</span></span><br><span class="line">               r.left = p;</span><br><span class="line">               p.parent = r;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>左旋小结：</p>
<blockquote>
<p>1.需要左旋节点 p 的右孩子 r 必须存在，并且将r取代p的位置；</p>
<p>2.如果 r 存在左孩子，将r的左孩子设置为p的右孩子；</p>
<p>3.r成为p的父节点，p成为r的左孩子节点</p>
</blockquote>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/12.png" alt="左旋图"></p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/10_left.gif" alt="左旋动图"></p>
<h4 id="rotateRight-右旋"><a href="#rotateRight-右旋" class="headerlink" title="rotateRight():右旋"></a>rotateRight():右旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">             <span class="comment">//l:p左节点，pp:p的父节点，lr:p的左节点的右孩子节点</span></span><br><span class="line">    		TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    		<span class="comment">//右旋节点以及右旋节点的左孩子不为空</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将p的左节点的右孩子节点赋值给p的左节点，如果lr存在，将其父节点设置为p</span></span><br><span class="line">                <span class="comment">//1.这一步相当于在剔除p的左节点</span></span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="comment">//2.将剔除的l节点替换p的位置</span></span><br><span class="line">                <span class="comment">//将l父节点指向p父节点，相当于左孩子提升了一层</span></span><br><span class="line">        		<span class="comment">//2.1 p没有父节点，说明l 已经是顶层节点了，应该作为root 并且标为黑色</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//2.2 p有父节点，并且p是父节点的右节点，将父节点的右节点设置为l</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                 <span class="comment">//2.3 p有父节点，并且p是父节点的左节点，将父节点的左节点设置为l</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                <span class="comment">//交换p,l自父节点的连接</span></span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>右旋小结：</p>
<blockquote>
<p>需要右旋节点 p 的左孩子 l 必须存在：</p>
<p> 1.剔除 l 节点：将l的右节点设置为p的左节点；</p>
<ol start="2">
<li>l、p节点交换位置</li>
</ol>
</blockquote>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/13.png" alt="右旋图"></p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/11_right.gif" alt="右旋动图"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>红黑树整体的构建过程可参考下图演变过程，以插入数字10，5，9，3，6，7，19，32，24，17 为例</p>
<p><img src="http://xiaofeiyihui.gitee.io/cdn/images/hashmap/6.png" alt="1"></p>
<h3 id="2-删除方法"><a href="#2-删除方法" class="headerlink" title="2.删除方法"></a>2.删除方法</h3><h4 id="remove-gt-removeNode"><a href="#remove-gt-removeNode" class="headerlink" title="remove() -&gt; removeNode()"></a>remove() -&gt; removeNode()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">  *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">  *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">  *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">         <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">//前提：table里面有数据，并且找到的桶位的头结点不为null</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">         <span class="comment">//1.找到要删除的节点</span></span><br><span class="line">         <span class="comment">//1.1 头结点就是</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             node = p;</span><br><span class="line">         <span class="comment">//1.2 头结点不是，获取下一个节点</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 1.2.1 数据结构是红黑树，按红黑树的方式查找</span></span><br><span class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">             <span class="comment">// 1.2.2 数据结构是链表，按链表的方式查找</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key ||</span><br><span class="line">                          (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         node = e;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     p = e;</span><br><span class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 2. 找到要删除的节点</span></span><br><span class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                              (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">             <span class="comment">// 2.1 找到的节点是红黑数结构，按红黑树方式删除</span></span><br><span class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">             <span class="comment">// 2.2 找到的节点是链表</span></span><br><span class="line">             <span class="comment">//2.2.1 是头结点</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                 tab[index] = node.next;</span><br><span class="line">             <span class="comment">// 2.2.2 不是头结点</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 p.next = node.next;</span><br><span class="line">             <span class="comment">// 修改次数加1，size减1，返回删除的节点</span></span><br><span class="line">             ++modCount;</span><br><span class="line">             --size;</span><br><span class="line">             afterNodeRemoval(node);</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>删除涉及到removeTreeNode()方法不打算展开来讲，逻辑和添加要考虑的东西刚好相反，比如减少一个节点需要考虑是不是要把树结构转化为链表结构，在红黑树中删除还需要考虑树的平衡，里面也会涉及到左旋右旋，感兴趣的同学可以去看看源码。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>hashmap里面综合运用了数组，单链表，双向链表，平衡二叉树（AVL）等数据结构，使得hashmap在添加、删除，查找上的时间复杂度尽可能最低，所以为什么要研究数据结构，一句话，<strong>数据结构的最终目的是提高数据的处理速度</strong>。</p>
<p>这篇博客花了很多时间在上面，感觉自己成长了不少，后面将继续分析数据结构。</p>
<h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><h3 id="数据结构动画演示："><a href="#数据结构动画演示：" class="headerlink" title="数据结构动画演示："></a>数据结构动画演示：</h3><p>​     <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a> </p>
<pre><code>https://visualgo.net/zh/bst </code></pre>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/27/2019-11-27-%E6%97%A0%E6%AF%94%E5%BC%BA%E5%A4%A7%E7%9A%84JMH%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" rel="next" title="无比强大的JMH基准测试工具使用">
                  <i class="fa fa-chevron-left"></i> 无比强大的JMH基准测试工具使用
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap数据结构分析"><span class="nav-number">1.</span> <span class="nav-text">HashMap数据结构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap中使用的数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">HashMap中使用的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Node-class-："><span class="nav-number">1.1.1.</span> <span class="nav-text">1.Node.class  ：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-TreeNode-class："><span class="nav-number">1.1.2.</span> <span class="nav-text">2.TreeNode.class：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-hashmap自带的字段类的"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.hashmap自带的字段类的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-继承-AbstractMap-lt-K-V-gt-的字段"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.继承 AbstractMap&lt;K,V&gt;的字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap怎么运用这些数据结构"><span class="nav-number">1.2.</span> <span class="nav-text">HashMap怎么运用这些数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-构造方法"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-添加方法"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.添加方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-gt-putVal"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">put()  -&gt;  putVal()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap数据结构小结"><span class="nav-number">1.3.</span> <span class="nav-text">hashmap数据结构小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap源码分析"><span class="nav-number">2.</span> <span class="nav-text">hashmap源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-添加方法相关的源码"><span class="nav-number">2.1.</span> <span class="nav-text">1.添加方法相关的源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#resize-：扩容"><span class="nav-number">2.1.1.</span> <span class="nav-text">resize()：扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#putTreeVal-：树添加节点"><span class="nav-number">2.1.2.</span> <span class="nav-text">putTreeVal() ：树添加节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#treeifyBin-：转化为树"><span class="nav-number">2.1.3.</span> <span class="nav-text">treeifyBin()：转化为树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#treeify-：连接树形节点"><span class="nav-number">2.1.4.</span> <span class="nav-text">treeify()：连接树形节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#moveRootToFront-：将root设为头结点"><span class="nav-number">2.1.5.</span> <span class="nav-text">moveRootToFront()：将root设为头结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#balanceInsertion-平衡插入"><span class="nav-number">2.1.6.</span> <span class="nav-text">balanceInsertion():平衡插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rotateLeft-左旋"><span class="nav-number">2.1.7.</span> <span class="nav-text">rotateLeft() : 左旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rotateRight-右旋"><span class="nav-number">2.1.8.</span> <span class="nav-text">rotateRight():右旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">2.1.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-删除方法"><span class="nav-number">2.2.</span> <span class="nav-text">2.删除方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-gt-removeNode"><span class="nav-number">2.2.1.</span> <span class="nav-text">remove() -&gt; removeNode()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结："><span class="nav-number">3.</span> <span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资料："><span class="nav-number">4.</span> <span class="nav-text">资料：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构动画演示："><span class="nav-number">4.1.</span> <span class="nav-text">数据结构动画演示：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Mr.Li"
    src="/images/myAvatar.jpg">
  <p class="site-author-name" itemprop="name">Mr.Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script><script src="/js/bookmark.js?v=7.4.1"></script>



  


















  

  

  

</body>
</html>
